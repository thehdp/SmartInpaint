<!doctype html>
<html lang="es">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0" />
        <title>Smart Inpaint - M√≥vil Optimizado</title>

        <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
        <link rel="manifest" href="favicon/site.webmanifest">
        <link rel="icon" href="favicon/favicon.ico">
        <script
            async
            src="https://docs.opencv.org/4.8.0/opencv.js"
            onload="onOpenCvReady();"
            type="text/javascript"></script>
        <style>
            /* Estilos generales */
            body {
                font-family: "Segoe UI", sans-serif;
                background-color: #121212;
                color: #e0e0e0;
                display: flex;
                flex-direction: column;
                align-items: center;
                padding: 10px;
                margin: 0;
                overscroll-behavior-y: contain; 
            }
            h2 {
                margin: 10px 0 5px 0;
                color: #fff;
                text-align: center;
                font-size: 1.5rem;
            }
            .instructions {
                color: #4caf50;
                margin-bottom: 15px;
                font-size: 1rem;
                text-align: center;
                font-weight: bold;
                border: 1px solid #4caf50;
                padding: 8px;
                border-radius: 8px;
                background-color: rgba(76, 175, 80, 0.1);
            }

            /* Barra de herramientas */
            .toolbar {
                background-color: #1e1e1e;
                padding: 10px;
                border-radius: 10px;
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
                margin-bottom: 15px;
                align-items: center;
                justify-content: center;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
                border: 1px solid #333;
                width: 95%;
                z-index: 10;
            }
            button,
            label.btn,
            select {
                background-color: #333;
                color: white;
                border: 1px solid #555;
                padding: 10px 12px;
                border-radius: 6px;
                cursor: pointer;
                font-size: 14px;
                flex-grow: 1;
                text-align: center;
            }
            button.primary {
                background-color: #007bff;
                border: none;
                font-weight: bold;
            }
            button.danger {
                background-color: #d32f2f;
                border: none;
            }
            input[type="file"] {
                display: none;
            }
            .control-group {
                display: flex;
                flex-direction: column;
                font-size: 0.8em;
                color: #ccc;
                align-items: center;
                min-width: 45%;
            }
            .control-group input[type="range"] {
                width: 100%;
                margin-top: 5px;
            }
            #status {
                margin-bottom: 5px;
                font-weight: bold;
                min-height: 20px;
                text-align: center;
                font-size: 0.9em;
            }

            /* --- CONTENEDOR CANVAS --- */
            .canvas-container {
                position: relative;
                width: fit-content;
                height: fit-content;
                margin: 0 auto 50px auto;
                border: 1px solid #444;
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
                background: repeating-conic-gradient(#222 0% 25%, #333 0% 50%) 50% / 20px 20px;
                line-height: 0;
            }

            #canvasOutput {
                display: block;
                max-width: 100vw;
                height: auto;
                z-index: 1;
            }

            #canvasUI {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 2;
            }

            /* Estilo de la Lupa FIXED */
            #loupe {
                position: fixed;
                width: 140px;
                height: 140px;
                border-radius: 50%;
                border: 4px solid rgba(255, 255, 255, 0.9);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.8);
                overflow: hidden;
                z-index: 9999;
                display: none;
                pointer-events: none;
                background-repeat: no-repeat;
                background-color: #000;
            }

            /* --- NUEVO: OVERLAY DE PROCESAMIENTO --- */
            #processingOverlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(0, 0, 0, 0.85); /* Fondo oscuro semitransparente */
                z-index: 10000; /* Por encima de todo, incluida la lupa */
                display: none; /* Oculto por defecto */
                flex-direction: column;
                justify-content: center;
                align-items: center;
                color: white;
                font-size: 1.5rem;
                backdrop-filter: blur(5px); /* Efecto borroso moderno */
            }

            /* Animaci√≥n del spinner */
            .spinner {
                border: 8px solid rgba(255, 255, 255, 0.3);
                border-top: 8px solid #007bff; /* Color azul */
                border-radius: 50%;
                width: 70px;
                height: 70px;
                animation: spin 1.5s linear infinite;
                margin-bottom: 25px;
            }

            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>
    <body>
        <h2>Smart Inpaint</h2>
        <div class="instructions">
            üñêÔ∏è 1 dedo: PINTAR<br>
            ‚úåÔ∏è 2 dedos: BAJAR / SUBIR
        </div>
        <div id="status" style="color: #ff9800">Cargando librer√≠a...</div>

        <div class="toolbar">
            <label class="btn">üìÇ Foto <input type="file" id="fileInput" accept="image/*" /></label>

            <div class="control-group">
                <span>üñåÔ∏è Pincel: <span id="brushVal">40</span>px</span>
                <input type="range" id="brushSize" min="10" max="100" value="40" oninput="document.getElementById('brushVal').innerText = this.value" />
            </div>
            
            <div class="control-group">
                <span>‚≠ï Radio: <span id="radiusVal">50</span>px</span>
                <input type="range" id="inpaintRadius" min="10" max="100" value="50" oninput="document.getElementById('radiusVal').innerText = this.value" />
            </div>

            <div class="control-group">
                <span>üß† Modo:</span>
                <select id="inpaintAlgo">
                    <option value="TELEA">R√°pido (Telea)</option>
                    <option value="NS" selected>Detalle (NS)</option>
                </select>
            </div>

            <div class="control-group">
                <span>üîç Lupa:</span>
                <select id="loupeZoom">
                    <option value="2">2x</option>
                    <option value="3">3x</option>
                    <option value="4" selected>4x</option>
                </select>
            </div>

            <button id="processBtn" class="primary" disabled onclick="processInpaint()">‚ú® Procesar</button>
            <button onclick="downloadImage()">üíæ Guardar</button>
            <button class="danger" onclick="resetCanvas()">üóëÔ∏è Reiniciar</button>
        </div>

        <div class="canvas-container" id="canvasContainer">
            <canvas id="canvasOutput"></canvas>
            <canvas id="canvasUI"></canvas>
        </div>
        
        <div id="loupe"></div>

        <div id="processingOverlay">
            <div class="spinner"></div>
            <p>Procesando imagen...</p>
            <p style="font-size: 0.9rem; color: #aaa;">Por favor espera.</p>
        </div>

        <script>
            // --- Referencias ---
            const inputElement = document.getElementById("fileInput");
            const brushSizeRange = document.getElementById("brushSize");
            const loupeZoomSelect = document.getElementById("loupeZoom");
            const status = document.getElementById("status");
            const processBtn = document.getElementById("processBtn");
            const inpaintAlgoSelect = document.getElementById("inpaintAlgo");
            const inpaintRadiusRange = document.getElementById("inpaintRadius");
            const processingOverlay = document.getElementById("processingOverlay"); // Referencia al nuevo overlay
            
            const canvasOut = document.getElementById("canvasOutput");
            const ctxOut = canvasOut.getContext("2d");
            const canvasUI = document.getElementById("canvasUI");
            const ctxUI = canvasUI.getContext("2d");
            const loupeDiv = document.getElementById("loupe");

            let imgElement = new Image();
            let src = null, mask = null;
            let isDrawing = false, cvLoaded = false;
            let currentImageURL = null;

            function onOpenCvReady() {
                cvLoaded = true;
                status.innerHTML = "‚úÖ Listo. Carga una imagen.";
                status.style.color = "#4caf50";
            }

            inputElement.addEventListener("change", (e) => {
                if (!cvLoaded || e.target.files.length === 0) return;
                if (currentImageURL) URL.revokeObjectURL(currentImageURL);
                currentImageURL = URL.createObjectURL(e.target.files[0]);
                imgElement.src = currentImageURL;
            });

            imgElement.onload = function () {
                canvasOut.width = canvasUI.width = imgElement.width;
                canvasOut.height = canvasUI.height = imgElement.height;
                ctxOut.drawImage(imgElement, 0, 0);
                loupeDiv.style.backgroundImage = `url(${currentImageURL})`;

                if (src) src.delete();
                if (mask) mask.delete();

                let tempSrc = cv.imread(canvasOut);
                src = new cv.Mat();
                cv.cvtColor(tempSrc, src, cv.COLOR_RGBA2RGB);
                tempSrc.delete();

                mask = new cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC1);

                status.innerHTML = "üñåÔ∏è Dibuja sobre el objeto a borrar.";
                processBtn.disabled = false;
                ctxUI.clearRect(0, 0, canvasUI.width, canvasUI.height);
            };

            // --- SISTEMA DE GESTOS UNIFICADO ---

            function getPointerPos(e) {
                const rect = canvasUI.getBoundingClientRect();
                const scaleX = canvasUI.width / rect.width;
                const scaleY = canvasUI.height / rect.height;

                let clientX, clientY;
                if (e.touches && e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY,
                    clientX: clientX,
                    clientY: clientY
                };
            }

            function handleStart(e) {
                if (e.touches && e.touches.length > 1) {
                    isDrawing = false;
                    loupeDiv.style.display = "none";
                    return;
                }
                if (e.cancelable) e.preventDefault(); 
                isDrawing = true;
                handleMove(e);
            }

            function handleEnd(e) {
                if (e.cancelable) e.preventDefault();
                isDrawing = false;
                ctxUI.beginPath();
                loupeDiv.style.display = "none";
            }

            function handleMove(e) {
                if (e.touches && e.touches.length > 1) return;
                if (e.cancelable) e.preventDefault();
                if (!src) return;

                const pos = getPointerPos(e);
                const radius = parseInt(brushSizeRange.value);

                if (!isDrawing) ctxUI.clearRect(0, 0, canvasUI.width, canvasUI.height);

                ctxUI.lineWidth = radius * 2;
                ctxUI.lineCap = "round";
                ctxUI.lineJoin = "round";

                if (isDrawing) {
                    ctxUI.strokeStyle = "rgba(255, 0, 0, 0.6)";
                    ctxUI.lineTo(pos.x, pos.y);
                    ctxUI.stroke();
                    ctxUI.beginPath();
                    ctxUI.moveTo(pos.x, pos.y);

                    let color = new cv.Scalar(255);
                    let point = new cv.Point(pos.x, pos.y);
                    cv.circle(mask, point, radius, color, -1);
                }
                updateLoupe(pos.clientX, pos.clientY, pos.x, pos.y);
            }

            function updateLoupe(clientX, clientY, canvasX, canvasY) {
                loupeDiv.style.display = "block";
                const loupeSize = 140;
                const offset = 25;
                const viewportWidth = window.innerWidth;
                // const viewportHeight = window.innerHeight; // No se usa actualmente

                let finalLeft = clientX - loupeSize - offset;
                let finalTop = clientY - loupeSize - offset;

                if (finalLeft < 0) finalLeft = clientX + offset;
                if (finalTop < 0) finalTop = clientY + offset;
                if (finalLeft + loupeSize > viewportWidth) finalLeft = viewportWidth - loupeSize - 10;

                loupeDiv.style.left = finalLeft + "px";
                loupeDiv.style.top = finalTop + "px";

                const zoom = parseInt(loupeZoomSelect.value);
                const loupeRect = loupeDiv.getBoundingClientRect();
                const bgPosX = -(canvasX * zoom) + loupeRect.width / 2;
                const bgPosY = -(canvasY * zoom) + loupeRect.height / 2;

                loupeDiv.style.backgroundSize = `${canvasOut.width * zoom}px ${canvasOut.height * zoom}px`;
                loupeDiv.style.backgroundPosition = `${bgPosX}px ${bgPosY}px`;
            }

            // Listeners
            canvasUI.addEventListener("mousedown", handleStart);
            canvasUI.addEventListener("mousemove", handleMove);
            canvasUI.addEventListener("mouseup", handleEnd);
            canvasUI.addEventListener("mouseleave", () => {
                isDrawing = false;
                loupeDiv.style.display = "none";
                ctxUI.clearRect(0, 0, canvasUI.width, canvasUI.height);
                ctxUI.beginPath();
            });
            canvasUI.addEventListener("touchstart", handleStart, { passive: false });
            canvasUI.addEventListener("touchmove", handleMove, { passive: false });
            canvasUI.addEventListener("touchend", handleEnd, { passive: false });
            canvasUI.addEventListener("touchcancel", handleEnd);

            // --- FUNCI√ìN DE PROCESAMIENTO MODIFICADA ---
            function processInpaint() {
                if (!src) return;
                
                // 1. MOSTRAR EL OVERLAY GRANDE
                processingOverlay.style.display = "flex";
                
                // Opcional: Actualizar el status peque√±o tambi√©n
                status.innerHTML = "‚è≥ Procesando...";
                status.style.color = "#ffeb3b";

                loupeDiv.style.display = "none";
                ctxUI.clearRect(0, 0, canvasUI.width, canvasUI.height);

                // Usamos un setTimeout peque√±o para dar tiempo al navegador a renderizar el overlay antes de bloquearse con el c√°lculo
                setTimeout(() => {
                    try {
                        let dst = new cv.Mat();
                        let algorithm = (inpaintAlgoSelect.value === 'NS') ? cv.INPAINT_NS : cv.INPAINT_TELEA;
                        const inpaintRadius = parseInt(inpaintRadiusRange.value) || 50;

                        // Esta es la l√≠nea que bloquea el navegador
                        cv.inpaint(src, mask, dst, inpaintRadius, algorithm);
                        
                        cv.imshow("canvasOutput", dst);
                        src.delete();
                        src = dst.clone();
                        mask.delete();
                        mask = new cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC1);
                        dst.delete();

                        status.innerHTML = "‚úÖ Terminado.";
                        status.style.color = "#4caf50";
                        loupeDiv.style.backgroundImage = `url(${canvasOut.toDataURL()})`;
                    } catch (err) {
                        console.error(err);
                        status.innerHTML = "‚ùå Error: " + err;
                        status.style.color = "#d32f2f";
                    } finally {
                        // 2. OCULTAR EL OVERLAY SIEMPRE AL FINAL (√âxito o Error)
                        processingOverlay.style.display = "none";
                    }
                }, 100); // Aument√© un poco el tiempo para asegurar que se vea el loader
            }

            function resetCanvas() {
                if (!currentImageURL) return;
                imgElement.src = currentImageURL;
                status.innerHTML = "Reiniciado.";
            }

            function downloadImage() {
                const link = document.createElement("a");
                link.download = "SmartInpaint_Edit.png";
                link.href = canvasOut.toDataURL();
                link.click();
            }
        </script>
    </body>
</html>
